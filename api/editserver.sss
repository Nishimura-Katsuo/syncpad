"use strict";

new function () { // custom dynamically imported api in node.js
	/* global htmlDocs global */
	let textCRDT = require(htmlDocs + '/syncpad/crdt.js');
	let charPool = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	let guestNumber = 0, guestprefix = "Guest", site = 1;

	let randomStr = () => {
		let c = 12, retstr = "";

		while (c--) {
			retstr += charPool[(Math.random() * charPool.length) | 0];
		}

		return retstr;
	};

	if (!global.buffer) {
		global.buffer = {};
	}

	this.connect = (ws, wss) => { // websocket connection
		ws.on('message', data => {
			try {
				let input = JSON.parse(data);
				let output = {}, returnBuffer = false;

				if (input.buffer && input.buffer.length) {
					ws.currentbuffer = input.buffer;
					returnBuffer = true;
				} else if (!ws.currentbuffer) {
					output.buffer = ws.currentbuffer = randomStr();

					while (global.buffer[ws.currentbuffer] !== undefined) {
						output.buffer = ws.currentbuffer = randomStr();
					}

					returnBuffer = true;
				}

				if (!ws.site) {
					ws.site = site++;
					output.site = ws.site;
				}

				if (global.buffer[ws.currentbuffer] === undefined) {
					global.buffer[ws.currentbuffer] = new textCRDT();
					global.buffer[ws.currentbuffer].generateNodes('// type some code!');
				}

				if (input.nodes && input.nodes.length) {
					global.buffer[ws.currentbuffer].mergeNodes(input.nodes);
					wss.clients.forEach(client => {
						if (client !== ws && client.currentbuffer === ws.currentbuffer) {
							try {
								client.send(JSON.stringify({nodes: input.nodes}));
							} catch (err) {
								ws.send(JSON.stringify({error: err}));
							}
						}
					});
				}

				if (typeof input.username === 'string' && input.username.length) {
					if (input.username.slice(0, guestprefix.length) !== guestprefix) {
						output.username = ws.username = input.username;
					} else {
						output.username = ws.username = guestprefix + (++guestNumber);
					}
				} else if (!ws.username) {
					output.username = ws.username = guestprefix + (++guestNumber);
				}

				if (typeof input.username === 'string' && input.username.length && input.username.slice(0, guestprefix.length) !== guestprefix) {
					ws.username = input.username;
					output.username = ws.username;
				}

				if (input.chat && ws.username) {
					wss.clients.forEach(client => {
						if (client.currentbuffer === ws.currentbuffer) {
							try {
								client.send(JSON.stringify({chatter: ws.username, chat: input.chat}));
							} catch (err) {
								ws.send(JSON.stringify({error: err}));
							}
						}
					});
				}

				if (returnBuffer) {
					output.nodes = global.buffer[ws.currentbuffer].nodes;
				}

				let jo = JSON.stringify(output);

				if (jo !== '{}') {
					ws.send(jo);
				}
			} catch (err) {
				console.log(err);
				ws.send(JSON.stringify({error: err}));
			}
		});

		return true;
	};

	this.request = script => { // normal http/https request
		script.resolve("Editing is online!");
	};
};
